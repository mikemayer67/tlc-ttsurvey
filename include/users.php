<?php
namespace tlc\tts;

if(!defined('APP_DIR')) { http_response_code(405); error_log("Invalid entry attempt: ".__FILE__); die(); }

require_once(app_file("include/db.php"));
require_once(app_file("include/settings.php"));
require_once(app_file("include/validation.php"));


/**
 * The survey participant information is stored in two mysql tables
 *   tlc_tt_userids: details for each survey participant
 *   tlc_tt_anonids: mapping from userids to anonymous proxy ids
 *
 * The tlc_userids table contains the following columns:
 *   id:
 *     - primary key generated by mysql 
 *     - not explicitly used with in the survey app
 *   userid:
 *     - unique ID associated with each survey participant
 *     - selected by the participant when they registered for the survey
 *     - used by the survey app to map participants to their responses
 *   fullname:
 *     - the participant's full name as it will appear on the survey
 *       summary report.
 *     - provided by the participant when they register for the survey
 *     - may be modified by the participant once they have logged in
 *   email:
 *     - the participant's email address (optional)
 *     - provided by the participant when they register for the survey
 *     - may be added/modified by the participant once they have logged in
 *     - may be removed by the participant once they have logged in
 *   password:
 *     - the participant's password for logging into the survey
 *     - provided by the participant when they register for the survey
 *     - may be modified by the participant once they have logged in
 *     - stored internally as a one-way hash of the password
 *   anonid:
 *     - hash of the anonymous proxy if one has been assigned to userid
 *     - hash of the userid if no anonymous proxy has been assigned
 *   token:
 *     - used to enable use of cookies to log the user in without a password
 *     - generated by the plugin when the participant registers for the survey
 *     - stored in a cookie along with the userid if cookies are enabled
 *     - may be regenerated by the participant once they have logged in
 *
 * The tlc_anonids table contains the list of all assigned anonymous
 *   proxy ids with absolutely no linkage to the userid to which they
 *   were assigned
 **/

class User {
  private $_userid   = null;
  private $_fullname = null;
  private $_email    = null;
  private $_token    = null;
  private $_password = null;
  private $_anonid   = null;

  private static $_users = array();

  private function __construct($user_data)
  {
    // user_data input is expected to be an associative array
    //
    // The data in this array must have been validated/sanitized
    //   BEFORE calling this constructor.  The constructor assumes
    //   it to be valid and complete.

    $this->_userid   = $user_data['userid'];
    $this->_fullname = $user_data['fullname'];
    $this->_email    = $user_data['email'] ?? null;
    $this->_token    = $user_data['token'];
    $this->_password = $user_data['password'];
    $this->_anonid   = $user_data['anonid'];
  }

  public function userid()       { return $this->_userid; }
  public function fullname()     { return $this->_fullname; }
  public function email()        { return $this->_email ?? null; }
  public function access_token() { return $this->_token; }

  public static function lookup($key) 
  {
    if(strstr($key,"@")) { return self::from_email($key); }
    else                 { return self::from_userid($key); }
  }

  public static function from_userid($userid)
  {
    $user = self::$_users[$userid] ?? null;
    if(!$user) {
      $r = MySQLSelectRow('select * from tlc_tt_userids where userid=?','s',$userid);

      if($r) { 
        $user = new User($r); 
        self::$_users[$userid] = $user;
      }
    }
    return $user;
  }

  public static function from_email($email)
  {
    $result = MySQLSelectRows('select * from tlc_tt_userids where email=?','s',$email);

    $users = array();
    foreach($result as $user_data) {
      $userid = $user_data['userid'];
      $cur_user = self::$_users[$userid] ?? null;
      if($cur_user) {
        $users[] = $cur_user;
      } else {
        $user = new User($user_data);
        $users[] = $user;
        self::$_users[$userid] = $user;
      }
    }
    return $users;
  }

  public static function all_users()
  {
    // note this function bypasses the user cache.  It is 
    //   meant to only be used in admin capabilities
    $result = MySQLSelectRows('select * from tlc_tt_userids');
    $users = array();
    foreach($result as $user_data) {
      $users[] = new User($user_data);
    }
    return $users;
  }

  // Full Name

  public function set_fullname($fullname,&$error=0)
  {
    // Note this function will return:
    //   false if there was an issue with the update command
    //   0     if the command was ok, but no database update was needed
    //   1     if the command was ok and the fullname was updated

    $error = null;
    if(!adjust_and_validate_user_input('fullname',$fullname,$error)) {
      log_warning("Cannot update full name for $this->_userid: invalid name ($fullname)");
      return false;
    }

    $result = MySQLExecute('update tlc_tt_userids set fullname=? where userid=?','ss',$fullname,$this->_userid);

    if($result) { $this->_fullname = $fullname; }

    return $result;
  }

  public function set_fullname_and_notify($fullname,&$error=0)
  {
    $old_fullname = $this->_fullname;
    $rval = $this>set_fullname($fullname,$error);

    if($rval) { 
      if($email = $this->email()) {
        require_once app_file('include/sendmail.php');
        sendmail_profile($email, $this->userid(), ['name'=>[$old_fullname,$fullname]]);
      }
    }
    return $rval;
  }


  // Email

  public function set_email($email,&$error=0)
  {
    // Note this function will return: 
    //   false if there was an issue with the update command
    //   0     if the command was ok, but no database update was needed
    //   1     if the command was ok and the email address was updated

    $error = null;
    if(!adjust_and_validate_user_input('email',$email,$error)) {
      log_warning("Cannot update email for $this->_userid: invalid email ($email)");
      return false;
    }
    if($email) {
      $result = MySQLExecute('update tlc_tt_userids set email=? where userid=?','ss',$email,$this->_userid);
    } else {
      $result = MySQLExecute('update tlc_tt_userids set email=NULL where userid=?','s',$this->_userid);
    }

    if($result) { $this->_email = $email; }

    return $result;
  }

  public function set_email_and_notify($email,&$error=0)
  {
    $old_email = $this->_email;
    $rval = $this->set_email($email,$error);

    if($rval) { 
      if($email) {
        require_once app_file('include/sendmail.php');
        log_info("Sent updated email address to new address: $email");
        sendmail_profile($email, $this->userid(), ['email'=>[$old_email,$email]]);
      }
      if($old_email) {
        require_once app_file('include/sendmail.php');
        log_info("Sent updated email address to old address: $old_email");
        sendmail_profile($old_email, $this->userid(), ['email'=>[$old_email,$email]]);
      }
    }

    return $rval;
  }

  public function clear_email()            { return $this->set_email(null);            }
  public function clear_email_and_notify() { return $this->set_email_and_notify(null); }

  // Profile (fullname + email)

  public function update_profile($fullname,$email,&$error=0)
  {
    // $fullname should NOT be falsey... this will cause the update to fail
    // $email MAY be falsey... this will remove the email from the profile
    //
    // Note this function will return: 
    //   false if there was an issue with the update command
    //   0     if the command was ok, but no database update was needed
    //   true  if the command was ok and the either name or email address was updated

    // Grab the current values for fullname and email in case we need to reset them
    $old_fullname = $this->_fullname;
    $old_email    = $this->_email;
    
    // We're going to call two functions which modify the database.  If the second one
    //  fails, we're going to want to undo the first one.
    MySQLBeginTransaction();

    $fullname_updated = $this->set_fullname($fullname); 
    $email_updated    = $this->set_email($email); 

    if( ($fullname_updated === false) || ($email_updated === false) ) {
      // A return value of false indicates an issue with the user input or the update query
      // A return value of 0 indicates that the update query was valid, but there was no change 
      //   required in the database values.  This is ok
      MySQLRollback();
      $this->_fullname = $old_fullname;
      $this->_email    = $old_email;
      return false;
    } else {
      // The queries were successful (even if they had no change)
      //   Issue a commit to close the current transaction
      MySQLCommit();
    }

    if(!($fullname_updated || $email_updated)) {
      // neither was updated, but there was no error, per se.  return 0
      return 0;
    }

    return true;
  }

  public function update_profile_and_notify($fullname,$email,&$error=0)
  {
    $old_fullname = $this->_fullname;
    $old_email    = $this->_email;

    $rval = $this->update_profile($fullname,$email,$error);

    if($rval) {
      $is_new_email = ($email !== $old_email);
      if($email) {
        $to = $is_new_email ? 'to new address' : 'to';
        log_info("Sending updated profile $to: $email");
        require_once app_file('include/sendmail.php');
        sendmail_profile($email, $this->userid(), [
          'name' =>[$old_fullname, $fullname],
          'email'=>[$old_email,$email]
        ]);
      }
      if($old_email && $is_new_email) {
        log_info("Sending updated profile to old address: $old_email");
        require_once app_file('include/sendmail.php');
        sendmail_profile($old_email, $this->userid(), [
          'name' =>[$old_fullname, $fullname],
          'email'=>[$old_email,$email]
        ]);
      }
    }

    return $rval;
  }


  // Password

  public function validate_password($password)
  {
    return password_verify($password,$this->_password);
  }

  public function get_password_reset_token()
  {
    // Only one active reset request at a time
    MySQLExecute("delete from tlc_tt_reset_tokens where userid=?",'s',$this->_userid);
    $token = gen_token(pwreset_length());
    $expires = time() + 60*pwreset_timeout();
    $expires = gmdate('Y-m-d H:i:s', $expires);
    $r = MySQLExecute("insert into tlc_tt_reset_tokens values (?,'$token','$expires')",'s',$this->_userid);

    return $r ? $token : null;
  }

  public function update_password($token,$password,&$error=null)
  {
    $error = null;
    $sql = "select token,expires from tlc_tt_user_reset_tokens where userid=?";
    $result = MySQLSelectRow($sql,'s', $this->_userid);
    if(!$result) {
      $error = "No current password reset request";
      return false;
    }
    // You only get one chance per reset request
    MySQLExecute("delete from tlc_tt_reset_tokens where userid=?",'s',$this->_userid);
    if( $token !== $result['token'] ) {
      $error = "Invalid reset request";
      return false;
    }
    $expires = strtotime($result['expires'].' UTC');
    $now = time();
    if($now > $expires) {
      $error = "Password reset request has expired";
      return false;
    }

    return $this->set_password_and_notify($password,$error);
  }

  public function set_password($password,&$error=0)
  {
    // Note this function will return: 
    //   false if there was an issue with the update command
    //   0     if the command was ok, but no database update was needed
    //   1     if the command was ok and the password was updated

    $error = null;
    if(!adjust_and_validate_user_input('password',$password) ) {
      log_info("Cannot update password for $this->_userid: invalid password");
      $error = 'invalid password';
      return false;
    }
    $password = password_hash($password,PASSWORD_DEFAULT);

    $result = MySQLExecute('update tlc_tt_userids set password=? where userid=?', 'ss', $password, $this->_userid);

    if($result) { $this->_password = $password; }

    return $result;
  }

  public function set_password_and_notify($password,&$error=0)
  {
    $rval = $this->set_password($password,$error);

    if($rval) { 
      $email = $this->email();
      if($email) {
        require_once app_file('include/sendmail.php');
        sendmail_profile($email, $this->userid(), ['password']);
      }
    }
    return $rval;
  }

  // Access Token

  public function validate_access_token($token)
  {
    return $token === $this->_token;
  }

  public function regenerate_access_token()
  {
    $new_token = gen_token();
    $result = MySQLExecute('update tlc_tt_userids set token=? where userid=?', 'ss', $new_token, $this->_userid);
    if(!$result) { return false; }
    $this->_token = $new_token;
    return $new_token;
  }

  // Anonymous Proxy

  public function get_anonid()
  {
    if( password_verify( $this->_userid, $this->_anonid ) ) { return null; }

    // try to find the existing anonymous proxy id
    $anonids = MySQLSelectValues('select * from tlc_tt_anonids');
    foreach( $anonids as $anonid ) {
      if( password_verify($anonid,$this->_anonid) ) { return $anonid; }
    }
    log_warning("Failed to locate anonid for $this->_userid");
    return null;
  }

  public function get_or_create_anonid()
  {
    $anonid = $this->get_anonid();
    if($anonid) { return $anonid; }

    // Either the userid was never associated with an anonymous proxy or
    //   We've somehow managed to lose that anonymous proxy id... 
    // Either way, we need to generate a new one

    // wrap this in a transaction so that we ensure either both or neither
    //   the userid and anonid tables are updated

    MySQLBeginTransaction();
    $anonid = 'anon_' . strtolower(gen_token(10));
    $result = MySQLExecute('insert into tlc_tt_anonids values (?)','s',$anonid);
    if(!$result) { 
      MySQLRollback();
      internal_error("Failed to insert $anonid into tlc_tt_anonids"); }

    $anonid_hash = password_hash($anonid,PASSWORD_DEFAULT);
    $result = MySQLExecute('update tlc_tt_userids set anonid=? where userid=?','ss',$anonid_hash,$this->_userid);
    if(!$result) { 
      MySQLRollback();
      internal_error("Failed to add anonid to $this->_userid in tlc_tt_userids");
    }

    MySQLCommit();
    $this->_anonid = $anonid_hash;

    return $anonid;
  }
}


function create_new_user($userid,$fullname,$password,$email=null)
{
  // inputs should be validated before calling this function... but as
  //   we're about to add this to the database, we'll validate them
  //   one last time.  If there is an issue, then there is an internal
  //   error in the app... so die
  $error = '';
  if(!adjust_and_validate_user_input('userid',$userid,$error)) {
    internal_error("Error while creating new user: userid $error");
  }
  if(!adjust_and_validate_user_input('fullname',$fullname,$error)) {
    internal_error("Error while creating new user: fullname $error");
  }
  if(!adjust_and_validate_user_input('password',$password,$error)) {
    internal_error("Error while creating new user: password $error");
  }
  if(!adjust_and_validate_user_input('email',$email,$error)) {
    internal_error("Error while creating new user: email $error");
  }

  $token    = gen_token();
  $password = password_hash($password,PASSWORD_DEFAULT);
  $anonid   = password_hash($userid,PASSWORD_DEFAULT);

  if($email) {
    $r = MySQLExecute(
      "insert into tlc_tt_userids (userid,fullname,email,token,password,anonid) values (?,?,?,?,?,?)",
      "ssssss",
      $userid,$fullname,$email,$token,$password,$anonid
    );
  } else {
    $r = MySQLExecute(
      "insert into tlc_tt_userids (userid,fullname,token,password,anonid) values (?,?,?,?,?)",
      "sssss",
      $userid,$fullname,$token,$password,$anonid
    );
  }

  // Construct and return the new User instance
  if($r) { $r = User::from_userid($userid); }

  return $r;
}

function validate_user_password($userid,$password)
{
  $user = User::from_userid($userid);
  if(!$user) {
    log_info("Failed to validate password for $userid (invalid userid)");
    return false;
  }
  if(!$user->validate_password($password)) {
    log_info("Failed to validate password for $userid (invalid password)");
    return false;
  }
  return true;
}

function validate_user_access_token($userid,$token)
{
  $user = User::from_userid($userid);
  if(!$user) { return false; }
  return $user->validate_access_token($token);
}
